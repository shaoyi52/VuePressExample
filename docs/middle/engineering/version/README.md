---
sidebar: auto
---
# 版本控制（Git）

版本控制指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是工程化管理里至关重要的一个环节，功能如下。

* 实现跨区域多人协同开发。
* 追踪和记载一个或者多个文件的历史记录。
* 组织和保护源代码及文档。
* 统计工作量。
* 并行开发，提高开发效率。
* 跟踪记录整个软件的开发过程。
* 减轻开发人员的负担，节省时间，同时减少人为错误。

版本控制最主要的功能就是追踪文件的变更。

## 提交规范

我们在使用Git作为项目的版本控制管理工具时，每次编写完新功能都需要提交（commit），并编写对应的提交信息（commit message）。如代码所示。

```
git commit -m 'update' // 更新了什么？
git commit -m 'fix' // 修复了什么？
git commit -m 'finish' // 完成了什么？
```

分析上述示例，可以发现存在以下问题。

* 不能直接知晓本次改动的模块，需要对比文件改动路径。
* 不能直接知晓本次改动的功能点，需要通过代码评审（Code Review）阅读改动的功能代码。
* 不能直接追踪某类型的提交，例如，功能新增、缺陷修复、重构等。

因此需要建立一套完整的规范对commit message进行约束，规范项目工程中的提交过程。

#### Conventional Commits

业内最成熟的规范就是约定式提交规范（Conventional Commits），它起源于AngularJSGit Commit Message Conventions，并在很大程度上以其为依据，是一种基于提交信息的轻量级约定，通过制定一些基本且简单的规则来创建清晰的提交历史，方便开发人员持续地维护项目。

在遵守约定式提交规范的项目中，开发人员能够通过提交信息一目了然地查看项目迭代中的功能迭代、缺陷修复、不兼容性改动及重构等信息，同时，系统能在项目持续集成阶段根据提交信息的类型（type）做出不同的自动化行为

#### 结构

整个结构主要包含header、body、footer三部分，其中header又包括type、scope、subject。在通常情况下，开发人员在commit message时一般只填写header中的type和subject部分，其余配置项都作为可选项。只有当type和subject部分无法准确描述提交内容时才使用它们进行补充。具体读者可以自行了解。[Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)

## 分支管理

在项目开发的过程中，选择一个合适的分支模式来管理代码十分重要，通常需要根据项目自身的业务特点和团队规模来选择合适的分支模式。常见的分支模式主要有TBD、Git-Flow、GitHub-Flow及GitLab-Flow。

### TBD

TBD（Trunk-Based Development）的中文名称为主干开发模式。在该模式下，开发人员在一个分支上进行协作开发，只保留一条长期稳定的开发分支，并且不允许新建任何长期存在的开发分支，任何代码的变更都更新到主干（master）分支上，当需要发布时，根据版本号拉一个release分支，通过merge或者cherry-pick将代码提交到对应的发布分支上。

#### 分支模型

* master：所有的开发都在主干上进行，包括功能开发、缺陷修复等。
* release：发布分支，根据版本发布的节奏，从master分支拉取特定版本进行发布

TBD要求每次变更提交的改动功能点都要小且可控，同时要快速验证，保证主干始终处于可发布状态。对于一些处在开发过程中的特性，一般采用特性开关（Feature Toggle）进行隔离，避免对主干造成影响。针对开发中要频繁提交代码变更的问题，TBD允许代码变更先进入集成及验证阶段，但是在发布阶段必须通过特性开关暂时隐藏相关特性，在特性完成后才打开开关。

#### 注意事项

* 需要确保每次的改动足够小并且可控，短时间内能够完成验证，因为所有的改动及变更都在主干分支上。
* 有完善的团队协作及自动化测试流程，能够快速验证改动带来的影响。
* 主干分支需要始终处于可发布状态，避免其功能缺陷影响正常的发布流程。

#### 优点

* 分支少，合并冲突小，实践应用成本低，方便管理。
* 适合持续交付及部署，以及简单密集的需求交付。

#### 缺点

* 要求有较高的团队协作熟练度和完善的集成规范。
* 一般不适合开发持续时间长及功能复杂的业务。

### Git-Flow

在实际项目的开发维护中，需求在构建初期被切分成多个子需求，各个子需求的成果都需要经过测试，具备可视、可集成和可运行使用的特征，这就是敏捷开发。由于团队需要协作完成某一功能需求或者分别完成不同的功能需求，因此根据不同的功能需求创建对应开发分支的模式应运而生，其中最具有代表性的就是Git-Flow模式。

Git-Flow模式很好地解决了不同需求并行开发的问题。各个需求可以同时开工，结合敏捷开发的例子，每个迭代在开始时都从主干分支拉出一个功能分支，所有关于此需求的开发都在功能分支上进行，开发完成后把功能分支合并回主干分支，测试通过后进行发布。

Git-Flow流程最大的亮点是考虑了紧急缺陷的应对措施，整个流程显得过于复杂，所以在实施该方案前，需要对整个开发流程进行系统的学习并借助Git-Flow等工具进行开发。

#### 分支模型

* feature：功能开发分支。
* develop：开发主干分支，包含所有的特性功能，一般是单个迭代里feature分支的集合。
* release：版本发布分支。
* master：稳定分支，保存最新的已发布代码。
* hotfix：修复线上问题的临时分支。

#### 工作流程

1. 当开发人员需要开发一个功能时，从develop分支中切出一个feature分支，为避免重复，可以使用开发人员与需求名称组合的方式进行命名。
2. 当功能开发完成后，需要将对应的feature分支合入develop分支，这里一般使用git merge--no-ff，它可以保存功能分支历史，能够更好地查看merge历史以及branch状态。git merge不会显示feature，只保留单条分支记录。
3. develop分支为只读唯一分支，只能从其他分支合并。从develop分支拉取release分支，然后进行测试。
4. release分支用于提交给测试人员进行功能测试。测试过程中发现的缺陷在该分支进行修复。
5. 当release分支上线完成后，需要将release分支合并到develop和master，并打上tag。
6. 上线之后如果发现线上缺陷，则需要从master拉取hotfix进行缺陷修改。
7. 在hotfix分支通过测试上线后，需要将hotfix分支合并到develop和master，同样需要打上tag。

#### 优点

* 特性并行开发，效率高，代码独立。
* 适合复杂业务、大团队协同开发。
* 支持多版本发布。

#### 缺点

* 分支结构过于复杂，对于小型团队和项目负担太重。
* 涉及分支类型过多，每种类型的分支都有独特的用法，开发人员很难区分不同的分支，提高了学习成本。
* 需要进行分支维护，更新分支代码。
* 功能分支的生命周期过长会导致合并冲突。功能分支的生命周期越长，与开发分支之间的差异越大，其代码集成到开发分支可能导致的代码冲突范围越广。

### GitHub-Flow

GitHub-Flow是简化版的Git-Flow，它更加轻量，仅保留了master和feature分支，是一种以部署为中心的分支管理模式，通过简单的功能和规则，持续、高速、安全地进行部署。

因为GitHub-Flow不涉及发布分支，所以按照GitHub-Flow的标准，如果准备好发布一个版本，就可以对其进行部署，并且GitHub-Flow认为hotfix与feature在发布流程上应该统一，所以feature可以代替hotfix。

#### 分支模型

* feature：进行开发的分支，包括功能开发、缺陷修复。
* master：保存最新的已发布代码，随时处于可部署状态。

#### 规定

* master分支上的所有代码都是可以部署的最新版本。
* 在开发新功能时，需要从master分支创建一个feature分支，通常以新功能的名称对feature分支进行命名，来标志feature的唯一性，避免重复。
* 开发人员应当尽可能频繁地将代码改动提交到本地开发分支。同时，所有代码改动必须尽可能频繁地同步到服务器上具有相同名称的分支上，从而尽可能减少合并时的冲突。
* 如果要将新代码合并到master分支，则必须先发起PR（Pull Request），确保代码评审（CodeReview，CR）通过。
* 当feature分支通过CR之后或正在进行代码审查时，必须将分支部署到测试环境，以便相关人员进行验证。
* 如果feature分支通过了代码审查和测试，则必须尽快将代码合并到master分支，并确定master分支处于随时可部署状态。

相对于Git-Flow，GitHub-Flow更加轻巧简便，同时，它满足了持续部署的需求。在GitHub-Flow模式中，开发人员能够快速检测master分支上的缺陷，并可以利用代码回滚等机制快速回滚缺陷代码。由于所有的功能改动都会被合并到master分支中，同时会经常部署master分支，所以已发布的代码基本上都能与master分支保持一致，这也是精益软件开发（LeanSoftware Development）和持续交付（ContinuousDelivery）所倡导的最佳实践。

### GitLab-Flow

GitLab-Flow与GitHub-Flow在开发流程上的区别并不大，只是GitLab-Flow将pull request改成了mergerequest，而merge request的用法与pull request类似，都可以作为CR的沟通方式。两者最大的区别体现在发布流程上，GitLab-Flow引入了对应生产环境的production分支和对应预发环境的pre-production分支。

#### 分支模型

* feature：开发人员进行功能开发的分支。
* master：部署在集成环境下的代码分支。
* pre-production：部署在预发环境下的代码分支。
* production：最新部署在生产环境下的代码分支。

#### 工作流程

1. 在功能开发完成后，提交merge request。
2. 在代码审查通过后，将feature分支的代码合并到master，并部署到集成环境进行验证。
3. 在验证通过后，提交merge request。
4. 合并master到pre-production分支，并部署到预发环境，进行预发环境验证。
5. 在预发环境验证成功后，提交mergerequest，将pre-production分支上的代码合并到production分支上。
6. 将production分支部署到正式环境中。

## Git Hook

和其他版本控制系统一样，Git也能在特定的重要动作发生时触发自定义脚本。有两组这样的钩子：客户端和服务器端。客户端钩子由诸如提交和合并这样的操作调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。

### 客户端钩子

* pre-commit

在提交commit message前运行。用于检查即将提交的快照，例如，检查是否有遗漏、运行测试、核查代码。如果该钩子以非零值退出，那么Git将放弃此次提交，可以利用该钩子来做一些代码提交前的准备工作，例如，提交的代码变动是否符合工程的代码lint规则。

* prepare-commit-msg

在commit message提交后，commit message被保存之前运行。该钩子接收以下信息并将其作为参数：存有当前提交信息的文件的路径、提交类型和修补提交的SHA-1校验。在大多数情况下，这样做对于一般的提交作用不大，然而对于那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。可以结合提交模板来使用它，动态地插入信息。

* commit-msg

接收存有当前提交信息的临时文件的路径并将其作为参数。如果该钩子脚本以非零值退出，那么Git将放弃提交，因此，可以用此钩子在提交通过前验证项目状态或提交信息。

* post-commit

在整个提交过程完成后运行。不接收任何参数，一般用于提交通知，触发一些自定义行为。

* pre-push

在git push运行时更新了远程引用但尚未传送对象时被调用。接收远程分支的名字和位置并将其作为参数，同时从标准输入中读取一系列待更新的引用。可以在推送开始之前，用它验证对引用的更新操作。如果它以非零值退出，则终止推送过程。

### 服务端常用钩子

* pre-receive

在处理来自客户端的推送时，该钩子最先被调用，它从标准输入获取一系列被推送的引用。如果它以非零值退出，则所有的推送内容都不会被接受。开发人员可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。

* update

update脚本和pre-receive脚本十分相似，不同之处在于它会为每一个准备更新的分支各运行一次。假如推送者同时向多个分支推送内容，那么pre-receive只运行一次，而update会为每一个被推送的分支各运行一次。它不会从标准输入中读取内容，而是接受三个参数：引用的名字（分支）、推送前的引用指向的内容的SHA-1值、用户准备推送的内容的SHA-1值。如果update脚本以非零值退出，则只有相应的引用会被拒绝，其余的依然会被更新。

* post-receive

在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。它接受与pre-receive相同的标准输入数据。它的用途包括给某个邮件列表发信，通知持续集成（continuousintegration）的服务器，或者更新问题追踪系统（ticket-tracking system），甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启、修改或者关闭。该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，如果想通过它进行其他操作，那么需要谨慎使用，因为它将占用系统资源很长时间。

在开发流程中，可以使用钩子对质量管控进行卡点。

## 相关工具

### commitizen

commitizen是一个格式化commit message的工具，通过npm即可快速安装它。

在完成配置提交commit message时，使用git cz来代替git commit，输入git cz后会出现命令行选项，通过流程化的引导自动生成符合格式的commitmessage。

### husky

husky是一个开源社区的Git Hook工具，属于前端工程化搭建中必不可少的部分。它可以让开发人员更加便捷快速地使用Git Hook，通过npm即可安装。

当开发人员进行commit或push时，可以使用它来运行测试、lint提交消息、lint代码。husky目前支持所有的Git Hook。

###  commitlint

commitlint是一个用于检测commit message的开源工具，它具有非常丰富的社区生态，可以帮助开发人员有效管理commit message，通过npm即可安装。

搭配husky可以用来校验message是否符合预期。只有通过校验才能成功提交。

### conventional-changelog-cli

conventional-changelog-cli是遵循约定式提交规范的cli工具，它可以根据遵守规范的commit message来自动生成更新日志。

## 总结

上述介绍了在前端工程中的Git版本控制管理系统的常见知识：约定式提交规范、分支管理模式、GitHook，以及如何运用开源社区的工具将这些知识串联起来，应用到实战中，提高版本控制的质量。

软件工程没有银弹，只有了解了这些知识点，在实际工作中才可能根据自身的业务特点和团队规模来选择适合的方案。分支模式没有绝对好的模式，只有适合的模式。如果上述分支模式都无法满足业务的实际需求，那么可以根据的业务特点和团队规模来定义分支模式，实际上大多数公司和项目团队的分支模式都是上述4种分支模式的变种。