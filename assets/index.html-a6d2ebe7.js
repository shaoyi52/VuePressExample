import{_ as i,o as e,c as a,e as p}from"./app-86c50f4f.js";const r={},l=p('<h1 id="代码质量" tabindex="-1"><a class="header-anchor" href="#代码质量" aria-hidden="true">#</a> 代码质量</h1><p>软件行业有一条公理——代码会不可避免地走向腐烂。腐烂并不意味着代码不可用，而是表示代码的维护成本极高。</p><p>代码质量一般指代码本身的质量，包括复杂度、重复率、代码风格等。代码是团队的共同财产，代码质量是团队技术水平和管理水平的直接体现。代码质量下降通常会自成因果，导致恶性循环。比如一下几点</p><ul><li>破窗效应：在烂代码上继续生产烂代码，开发人员的心理负担会小很多。</li><li>传染性：烂代码传递着一种不在意质量，只看业务成果的负面信息，会伤害团队的技术热情和工作氛围，导致更多烂代码出现。</li></ul><p>代码质量过硬则能带来以下好处。</p><ul><li>在发生问题时，能够帮助开发人员快速理解和定位。</li><li>可以加快应用的迭代速度，不必花费过多的时间来修复Bug和优化代码逻辑。</li><li>能够帮助新的项目开发成员更快、更容易地融入项目开发中。</li><li>便于项目组不同开发成员之间快速做好承接。</li><li>有效促进团队间交流合作，提升开发效率。</li></ul><p>在无外力影响的情况下，烂代码只会越来越多。需要主动采用技术或者管理手段来缓解甚至抑制烂代码越来越多的趋势。</p><h2 id="产生原因" tabindex="-1"><a class="header-anchor" href="#产生原因" aria-hidden="true">#</a> 产生原因</h2><p>烂代码产生的常见原因是业务压力大，开发人员没有时间或意愿追求代码质量。在向业务压力妥协产生烂代码后，开发效率会下降，导致业务压力增加，形成恶性循环。为了缓解业务压力，常见的做法是增加人力，但是单纯地增加人力，会因为工作风格不一致、沟通成本上升等原因导致烂代码更多。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><p>要遏制这种恶性循环，既需要主动对代码质量进行管控，也要持续进行技术升级，才能系统性地解决问题。不过两种方案都需要长期投入才能产生效果。</p><p>在通常情况下，人们倾向于通过增加人力快速解决业务压力的问题，而忽略了代码质量下降产生的负面影响，导致代码质量越来越差。代码质量可以采用传统的业界标准进行衡量，比如编码规范、可读性、可维护性、代码重复率及可测试性。</p><ul><li><p>编码规范：主要包括是否遵守了最佳实践和团队编码规范，是否包含可能出问题的代码，以及可能存在的安全漏洞。编码规范有助于提高团队协作的效率以及代码的可维护性。</p></li><li><p>可读性：Code Review是一个很好的检测代码可读性的手段。如果同事之间可以轻松地读懂彼此写的代码，就说明当前工程的代码可读性很好；反之则说明代码可读性有待提高。遵守编码规范也能让开发人员写出可读性更好的代码。</p></li><li><p>可维护性：代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；更具体地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等，就可能意味着代码易维护。除此之外，代码的易维护性还与项目代码量的多少、业务的复杂程度、用到的技术的复杂程度、文档是否全面等诸多因素有关。</p></li><li><p>代码重复率：遵守DRY（Don&#39;t Repeat Yourself）原则，尽量减少重复代码的编写工作，复用已有的代码。定期对项目进行代码重复度检测是一件很有意义的事，可以帮助开发人员发现冗余代码，进行代码抽象和重构。重复的代码一旦出错，就意味着大量的工作和持续的不可控。如果代码中有大量的重复代码，就要考虑将重复的代码提取出来，封装成公共的方法或组件。</p></li><li><p>可测试性：代码的可测试性同样可以反映代码质量的好坏。代码的可测试性差，比较难写单元测试，基本上就能说明代码设计得有问题。</p></li></ul><p>根据以上5个原则，可以在不同阶段进行应对和治理。在开发时，在团队中建立代码规范制度，例如，代码缩进、注释风格等。在代码提交时，基于代码规范使用自动化工具进行代码质量检查，例如，代码规范、圈复杂度、代码重复率等。在代码评审时，从业务逻辑角度入手，评估需求还原度，针对异常边界情况提出疑问，帮助代码编写人员进行自我审查。</p><h2 id="代码质量指标" tabindex="-1"><a class="header-anchor" href="#代码质量指标" aria-hidden="true">#</a> 代码质量指标</h2><h3 id="主观指标" tabindex="-1"><a class="header-anchor" href="#主观指标" aria-hidden="true">#</a> 主观指标</h3><p>主观指标指代码评审人员给出的主观判定。它们可以有效地评估代码在特定业务场景下的质量可靠性，但是需要耗费人力去进行代码评审（Code Review，CR），并且对CR人员的能力素质有一定要求。CR有两个要点：一是要统一团队规范，否则即使对于同一个问题，不同人员给出的建议也可能不同，很难做到有效统一；另一点是要把评审做到位，避免形式主义。主观指标包括以下两点。</p><ul><li><p>可扩展性：指代码为了应对将来的需求变化而需要具备的扩展能力，当新的功能需求出现时，无须或仅需少量修改代码，也无须对整个系统进行重构或者重建。</p></li><li><p>可读性。指开发人员能否通过阅读代码快速明白当前函数的功能，这将有助于协同式开发、后续功能迭代以及重构等工作的推进。提升代码可读性的方式有许多，包括注释和文档、统一的缩进、统一的变量命名方案等。以统一的变量命名方案为例，常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法，一旦选用或设置好命名规则，在编写程序时就应保持格式一致。</p></li></ul><h3 id="客观指标" tabindex="-1"><a class="header-anchor" href="#客观指标" aria-hidden="true">#</a> 客观指标</h3><p>主观指标需要消耗人力，当人力资源不足或者能力有限时，可以由计算机代替评审人员对代码进行质量评估。</p><ul><li><p>圈复杂度：也被称为条件复杂度——用来衡量模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理地预防错误所需测试的最少路径数。根据历史经验，程序出错的概率和圈复杂度的大小有着很大关系。圈复杂度越大就说明代码质量越低，越难以测试和维护，代码运行时出现问题的概率越大。</p></li><li><p>千行代码Bug率，它由代码行数和Bug数两个指标共同组成，计算公式：千行代码Bug率=Bug数量/（代码行数/1000）。一般来说，千行代码Bug率的数值越小代表代码质量越好。</p></li><li><p>代码重复率。一个项目在不断开发迭代、功能累加的过程中，重复代码的出现是不可避免的，其出现的原因大多数是复制、粘贴代码。</p></li></ul><p>度量指标会激励团队重视并改善能够度量的元素，但也会导致团队忽视无法度量的元素，并使得问题进一步恶化。因此，团队管理者应该慎重评估指标的重要性和合理性。</p><h2 id="代码管理" tabindex="-1"><a class="header-anchor" href="#代码管理" aria-hidden="true">#</a> 代码管理</h2><h3 id="代码规范" tabindex="-1"><a class="header-anchor" href="#代码规范" aria-hidden="true">#</a> 代码规范</h3><p>代码规范指开发人员进行编码时需要遵守的统一约定。代码规范可以细分为编码规范和注释规范两类。</p><p>编码规范包含许多子类，例如，代码风格、代码性能、代码安全性等。以代码风格为例，又包括代码的缩进、换行、命名等子项。</p><p>注释规范按功能主要分为说明性注释和提示性注释。</p><h4 id="eslint-prettier" tabindex="-1"><a class="header-anchor" href="#eslint-prettier" aria-hidden="true">#</a> ESLint+Prettier</h4><p>如上所示，代码的规范涉及的过多，从规范的制定到规范的检查需要投入的成本是非常大的，我们需要借用第三方工具来落实规范并且降低成本。ESLint和Prettier就是这样一个工具。前者侧重于语法规范而后者侧重于代码风格。特点如下</p><ul><li>支持自定义规则</li><li>支持引入规则集</li><li>支持插件扩展（eslint可配置Prettier优先）</li><li>丰富生态（编辑器插件..）</li></ul><p>在项目中引入ESLint和Prettier，为我们省去了规范制定、规范检查的成本，只需要在CR中审查主观指标的代码即可。</p><p>配合编辑器插件，可以将不符合预期的代码在编辑器中体现出来，并且支持自动修复，开发人员无需面向规范开发。</p><p>配合Git hooks + 自动修复，可以确保每次提交的代码都是符合规范的，当遇到修复失败时会终止后续操作，比如在客户端触发钩子，校验失败后终止提交。</p><p>有关Lint的工具还有很多，比如还有针对css的Stylelint。读者可以自行查阅。</p><h3 id="工程目录结构" tabindex="-1"><a class="header-anchor" href="#工程目录结构" aria-hidden="true">#</a> 工程目录结构</h3><p>一个优秀的工程目录结构可以很好地将代码的作用域进行划分，不同模块下的代码需要关注的功能点不一致。如果开发人员能通过目录结构快速找到对应的功能模块，那么将有效提高协同开发的效率。</p><p>在目录结构的设计上，开发人员可以遵循领域驱动设计（Domain Driven Design，DDD）原则。</p><p>一般主流脚手架或者构建工具（Cli、Vite）创建的项目都符合领域驱动设计，开发者们可以在此基础上进行扩展。</p><h3 id="类型约束" tabindex="-1"><a class="header-anchor" href="#类型约束" aria-hidden="true">#</a> 类型约束</h3><p>作为一门弱类型语言，开发人员在使用JavaScript进行开发时会非常灵活，但正是由于JavaScript太过灵活，在实际开发中，开发人员编写的代码可能存在很多隐患，例如类型隐式转换。</p><p>这种问题对于大型工程来说是非常致命的，并且排查起来极其麻烦。因此，开发人员需要引入TypeScript，对代码进行类型约束。</p><p>从开发效率上来看，TypeScript和编辑器的协作性非常好，它能够在开发阶段给予开发人员代码片段提示。从开发质量上来看，它帮助开发人员清晰确定当前字段的类型。除此之外，TypeScript会提供最新的和不断发展的JavaScript特性，这些新特性会在tsc编译阶段被降级成可兼容的API，然后输出纯净、简洁的JavaScript代码，它们可以运行在任何浏览器和Node.js环境中。TypeScript更多内容，读者可阅读官方文档，此文章不做过多描述。</p><p>TypeScript的tsc工具也可以搭配Git hooks使用在涉及代码提交时进行类型校验。</p><h2 id="接口管理" tabindex="-1"><a class="header-anchor" href="#接口管理" aria-hidden="true">#</a> 接口管理</h2><h3 id="接口mock" tabindex="-1"><a class="header-anchor" href="#接口mock" aria-hidden="true">#</a> 接口mock</h3><p>接口作为前端工程中至关重要的一个环节，其代码质量的管理也尤为重要。如果接口的数据量比较少、逻辑复杂度低，那么mock数据很容易处理后端接口未准备好的问题：前端可以在接口方法里进行数据硬编码并将相应接口注释掉，等联调时再取消注释即可。</p><p>这样做虽然开发起来比较方便，但是在提交过程中会产生很多无用的代码。同时，手写的mock数据没有与工程代码隔离，具有侵入性，会污染service层的接口方法。这种方法在项目和人员都较大时无疑会增加风险。</p><h4 id="mock-js" tabindex="-1"><a class="header-anchor" href="#mock-js" aria-hidden="true">#</a> Mock.js</h4><p>Mock.js属于工具类接口mock方案，它的原理是通过拦截XMLHttpRequest请求来实现数据mock，通过该方式进行的mock不会发起真实的请求。它会代理XMLHttpRequest请求，直接在函数的执行层面劫持并返回。</p><h4 id="yapi" tabindex="-1"><a class="header-anchor" href="#yapi" aria-hidden="true">#</a> YApi</h4><p>YApi属于平台类接口mock方案，它是一个高效、易用、功能强大的可视化接口管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发人员轻松创建、发布、维护API。</p><h3 id="接口类型约束" tabindex="-1"><a class="header-anchor" href="#接口类型约束" aria-hidden="true">#</a> 接口类型约束</h3><p>在实际开发过程中，当开发人员需要查看接口字段的类型和作用说明时，通常还会依赖接口文档。这种方式不仅会降低开发效率，还增加了系统的不稳定性。</p><p>当系统进行重构或者需要对涉及接口的字段进行增删及类型改动时，先查找关键词再手动进行替换修改的方式人力成本非常高，并且极容易改错或者遗漏。</p><p>为了避免上述问题，开发人员可以使用TypeScript对接口方法进行类型约束。大多数请求库都支持响应类型。</p><p>在引入接口类型约束后，开发人员不需要再频繁查阅接口文档，在大部分情况下直接通过编辑器的提示便能正常地进行开发。这种方式可以有效提高研发效率、保障接口质量。</p><h2 id="代码质量平台sonarqube" tabindex="-1"><a class="header-anchor" href="#代码质量平台sonarqube" aria-hidden="true">#</a> 代码质量平台SonarQube</h2><p>SonarQube是代码质量管理的开源平台，可以用于管理源代码的质量，能够从7个维度检测代码质量，展示静态代码扫描的结果。</p><ul><li><p>代码设计。SonarQube会检测代码中的依赖、循环等关系，来判断当前代码的设计是否合理。</p></li><li><p>代码规范。SonarQube会使用CheckStyle等代码检测工具扫描代码规范是否合理，从而规范代码的编写。</p></li><li><p>代码潜在缺陷。SonarQube会使用FindBugs等代码检测工具扫描代码是否存在问题，找出代码中的潜在缺陷。</p></li><li><p>代码复杂度。如果代码的复杂度过高，则会导致维护困难。SonarQube会分析代码的复杂度，当增量代码超出复杂度阈值时及时给出预警，从而避免代码腐败。</p></li><li><p>代码重复率。如果代码中存在大量的重复代码则说明当前质量低下，大部分此类问题都是在代码实现时没有进行抽象复用造成的，SonarQube可以扫描出这些重复率高的模块，并给出对应的提示。</p></li><li><p>代码注释。通常来说，代码缺少注释会使其可读性下降，尤其在团队人员变动时，新的开发人员仅能通过阅读代码来了解代码功能。SonarQube能扫描代码，找出代码中注释过少或过多的地方。</p></li><li><p>代码单元测试覆盖率。SonarQube能够很方便地统计代码单元测试的覆盖率，从而保证代码的质量。</p></li></ul><p>SonarQube巧妙地使用了插件机制。通过插件机制，可以集成不同的测试工具、代码分析工具，以及持续集成工具，SonarQube还对大量的持续集成工具提供了接口支持，开发人员可以很方便地在持续集成工具中使用SonarQube。</p><h3 id="指标" tabindex="-1"><a class="header-anchor" href="#指标" aria-hidden="true">#</a> 指标</h3><p>SonarQube提供了一系列的指标帮助开发人员了解项目的代码质量现状。</p><ul><li><p>可靠性（Reliability）：只要有一个次要Bug，项目评级就为B；只要有一个重要Bug，项目评级就为C；只要有一个严重Bug，项目评级就为D；只要有一个阻断性Bug，项目评级就为E。</p></li><li><p>安全性（Security）是衡量代码漏洞数量的标准，从低到高分为A、B、C、D、E 5个等级：没有漏洞，项目评级为A；只要有一个次要漏洞，项目评级就为B；只要有一个重要漏洞，项目评级就为C；只要有一个严重漏洞，项目评级就为D；只要有一个阻断性漏洞，项目评级就为E。</p></li><li><p>可维护性（Maintainability）可以被用来衡量代码质量。SonarQube建立了一套公式：可维护性数值=技术债务成本/项目代码总开发成本，将可维护性进行了量化，从低到高分为A、B、C、D、E 5个等级，A到D的默认值分别为0.05、0.1、0.2、0.5，只要超过0.5评级就为E。技术债务成本指修复当前不规范的代码需要投入的时间，项目代码总开发成本指从零开始重写代码所需的成本。SonarQube默认的开发一行代码的成本为30分钟，如果总代码行数为100行，那么项目代码总开发成本为3000分钟，假设技术债务为300分钟，则可维护性数值为0.1，对应的可维护性评级为B。</p></li><li><p>覆盖率（Coverage）由条件覆盖率和行覆盖率共同组成，即单元测试覆盖的源代码行数占总代码行数的比率。</p></li><li><p>重复（Duplications）：SonarQube会扫描项目中代码的重复情况，开发人员可以通过该指标查看到代码的重复密度、重复行数、重复文件块及重复文件数量等信息。</p></li><li><p>大小（Size）：该指标直观反映当前项目的代码体量。通过该指标可以查看到新增代码行数、总代码行数、方法数、目录数、文件数以及注释行数等信息。</p></li><li><p>复杂度（Complexity）：指代码的圈复杂度，复杂度越高代表代码越难以阅读和维护。代码中的条件分支越多，代码的复杂度就越高，测试和维护越困难。</p></li><li><p>问题（Issues）：将项目中扫描出来的问题进行归类，按处理状态划分为新增的违规、违规、待处理的问题、重开的问题、已确认问题、误判的问题、不需要修复的问题。</p></li></ul><p>以上几个指标在一定程度上能够反映当前项目的代码质量，SonarQube还会根据问题给出相关的建议</p>',64),h=[l];function t(n,d){return e(),a("div",null,h)}const o=i(r,[["render",t],["__file","index.html.vue"]]);export{o as default};
