import{_ as e,o as a,c as i,e as l}from"./app-2f1dce05.js";const r={},n=l('<h1 id="组件化" tabindex="-1"><a class="header-anchor" href="#组件化" aria-hidden="true">#</a> 组件化</h1><p>组件是对公共模块的封装实现，可以有效解决前端项目的复用性问题，通常这些公共模块都是项目中使用频率特别高或者具有共性的模块。组件建设一方面可以方便跨项目的组件复用，减少重复的代码；另一方面，可以方便团队分工协作，最终目的都是为了提高研发质量，保障研发效率。</p><p>同时也是帮助设计师快速构建UI稿，保证风格的一致性，为用户带来视觉和交互上的一致性，例如，颜色、字体、大小等。</p><h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h2><p>在进行组件开发时，应当遵循以下原则。</p><ul><li><p>高内聚：尽可能使得每个组件只完成一件事（最大限度地聚合）。</p></li><li><p>低耦合：组件与组件之间是低耦合的，只要遵循组件规范，就可以用一个组件轻易地替换另一个组件。</p></li><li><p>可复用性：组件的功能明确，实现清晰，API易于理解，可以在其他业务中被重复使用。</p></li></ul><h2 id="组件分类" tabindex="-1"><a class="header-anchor" href="#组件分类" aria-hidden="true">#</a> 组件分类</h2><p>大多数人对前端组件的认知仅停留在视图组件上，即肉眼可以捕捉的内容。实际上，按照不同的维度进行划分，可以得到以下不同结果。</p><h3 id="复杂度划分" tabindex="-1"><a class="header-anchor" href="#复杂度划分" aria-hidden="true">#</a> 复杂度划分</h3><ul><li><p>原子组件：颗粒度最细的组件，无法再继续拆分，例如，Button、Switch等。</p></li><li><p>复合组件：基于原子组件进行拼接得到的新组件，例如，ModalTable就是由modal和table拼接的复合组件。</p></li></ul><h3 id="可视化划分" tabindex="-1"><a class="header-anchor" href="#可视化划分" aria-hidden="true">#</a> 可视化划分</h3><ul><li><p>视图组件：在页面上渲染出来，直接呈现在屏幕上的组件，能被肉眼捕捉到。</p></li><li><p>功能组件：无法通过肉眼捕捉的组件，例如，时间格式化方法、状态管理等。</p></li></ul><h3 id="功能领域划分" tabindex="-1"><a class="header-anchor" href="#功能领域划分" aria-hidden="true">#</a> 功能领域划分</h3><ul><li><p>通用组件：可以跨业务项目实现复用的组件，例如，视图组件中的Button，功能组件中的状态管理等。</p></li><li><p>业务组件：一般具有业务属性，只有在特定的业务模块下才可以使用，例如，不同业务中的业务选择器等。</p></li></ul><h2 id="研发设计规范" tabindex="-1"><a class="header-anchor" href="#研发设计规范" aria-hidden="true">#</a> 研发设计规范</h2><p>组件是一种编程抽象化、代码组织化的方式，可以增加代码的复用性、灵活性，从而提高开发效率。通俗来讲就是开发人员对一段可复用的代码进行抽象封装，使得这部分代码能够在相同或类似的功能场景下，通过引用的形式实现复用。</p><p>组件在设计时应该遵守一定的原则。组件过度抽象会导致使用复杂度特别高，而抽象程度不够又会导致组件复用性特别差。以上两种情况都会导致产出的组件不合格，从而被少用甚至弃用。因此，开发人员应该根据具体的功能场景进行合理权衡，在两者之间找到一个平衡点。</p><p>按照组件的功能颗粒度对组件进行划分，可以得到原子组件和分子组件。明确组件的颗粒度可以帮助开发人员避免重复开发组件，最大程度实现组件的功能复用，不仅便于维护，而且能够提高研发效率。不可再拆分或者没有必要再拆分的组件被称为原子组件。如果组件至少包含一个原子组件，同时添加了功能代码片段进行功能扩展，就被称为分子组件。</p><p>明确组件颗粒度后就需要制定原子组件的研发设计规范，可以分为以下5部分。</p><ul><li><p>KISS（Keep It Simple And Stupid）原则。它的核心理念是让代码尽可能简单，并且保持代码的可读性。开发人员可以通过遵守代码规范、对函数进行清晰易懂的命名，以及添加说明性注释等方法来提高代码可读性。</p></li><li><p>YAGNI（You Ain&#39;t Gonna Need It）原则。它的核心理念是不要过度设计。例如，开发人员不要设计当前用不到的功能；不要编写当前用不到的代码。代码可以根据业务情况预留扩展点，但是不需要提前实现这些功能。</p></li><li><p>DRY（Don&#39;t Repeat Yourself）原则。它的核心理念是提高组件的复用性。同样功能的代码逻辑，只应该被实现一次。开发人员应该将公共部分抽象出来作为工具函数，从而提高代码的复用性和可维护性。例如，在大多数情况下，分子组件中的原子组件可以作为公共部分进行抽象，从而有效提高组件复用性。</p></li><li><p>LOD（Law Of Demeter）原则。它的核心理念是降低组件之间的耦合性，尽量做到能不依赖就不依赖。如果需要依赖，那么也应该尽可能依赖抽象部分，保持依赖关系上的松耦合。如果能够保持松耦合，当依赖部分发生变更时就能够将影响降至最低。即便是不兼容式改动，开发人员也能以最低成本迁移。</p></li><li><p>SRP（Single Responsibility Principle）原则。它的核心理念是一个组件应该只关注一个功能点。如果违反了该原则，就会导致组件内部出现大量的逻辑分支，从而使得逻辑混乱，组件难以拓展和维护。</p></li></ul><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>以上设计原则并不需要在同一时间内全部遵守，开发人员应该灵活运用以上设计原则。例如，在实际业务开发中，如果不能确定某一个功能将被复用，却为了这个暂时用不到的复用需求投入大量的时间、精力，从而导致开发成本上升，就不是很好的做法。同时，这也违反YAGNI原则。因此，在第一次编写代码时，开发人员不需要投入太多精力去考虑复用性。如果遇到复用场景，就应该遵循DRY原则，对代码进行重构，从而使其能够被复用。</p><h2 id="组件化与模块化" tabindex="-1"><a class="header-anchor" href="#组件化与模块化" aria-hidden="true">#</a> 组件化与模块化</h2><p>相对于自然语言，在软件编程领域内，module和component的定义更加复杂，边界也更加难以评定。不同的框架甚至不同的编程语言本身的一些机制都会引起对两者的混淆。</p><p>component是软件架构中的一个角色，而非编程语言领域内的术语，所以对其解读可以只从架构层面出发。而module虽然早期也仅停留在架构层面，但许多编程语言在版本更迭过程中将其演变成了一种语言自身的角色，比如ES6 Module，从而进一步加深了component和module的解读难度。</p><h3 id="angular" tabindex="-1"><a class="header-anchor" href="#angular" aria-hidden="true">#</a> Angular</h3><p>Angular是目前为数不多的将component和module进行明确区分的框架之一。component在Angular中的作用是管理视图中的某个片段，也可以简单理解为component便是这个片段的逻辑抽象。</p><h4 id="声明组件" tabindex="-1"><a class="header-anchor" href="#声明组件" aria-hidden="true">#</a> 声明组件</h4><p>声明一个component需要三个基本元素：template（模板）、style（样式）、selector（选择器），加上component的JavaScript逻辑。</p><h4 id="声明模块" tabindex="-1"><a class="header-anchor" href="#声明模块" aria-hidden="true">#</a> 声明模块</h4><p>module（即Angular中的NgModule）是一系列组件（component）、指令（directive）、管道（pipes）、子模块（submodule）以及其他逻辑的封装。每个module对应一项功能，并且不一定与视图相关，比如负责HTTP请求处理的HttpClientModule、路由管理的RouterModule等。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>Angular对component和module的定义对我们来说有非常深刻的借鉴意义，虽然目前React和Vue中暂时没有对module进行抽象，但我们也可以将其带入Angular语境中进行理解，比如可以将react-router/vue-router理解为Web应用程序的路由管理模块。从这个角度理解，component和module在软件编程领域内的语义就一目了然了。总体来说。前端领域内模块和组件的定义如下：</p><ul><li><p>模块和组件均为可分离的、有独立功能的一种封装对象。</p></li><li><p>模块强调功能性，其功能并非一定与视图相关。一个完整的应用程序由多个模块组成。</p></li><li><p>组件强调组合性，是一个视图片段的逻辑抽象。粒度比模块细，一个模块可包含一个或多个组件。</p></li></ul><p>在此基础之上，我们不妨进一步扩大对比范围：上层延展至应用程序，下层深入到编程语言基元。从下至上依次为编程语言基元、对象、组件、模块和应用程序，基元组成对象，对象组成组件，组件组成模块，模块组成应用。</p>',35),d=[n];function p(t,h){return a(),i("div",null,d)}const u=e(r,[["render",p],["__file","index.html.vue"]]);export{u as default};
